# Введение

Я разбил статью на две части: практику и теорию. В первой части я приведу в пример 10 задач, которые сильно похожи на задачи с реальных собеседований.

## Практика

### Задача на замыкание

Трудно представить собеседование на должность разработчика интерфейсов без задачки на замыкание. Сам по себе принцип замыкания прост, но всё ещё встречаются люди, которые не могут объяснить его суть. Нередко бывают случаи, когда кандидат вызубрил определение, но на практике использовать механизм не может.

### snake_case в camelCase

Нужно написать функцию, которая преобразует строки из стиля "snake_case" в "camelCase".

```javascript
function snakeToCamel() {
  /* solution */
}

snakeToCamel('hello_world') // "helloWorld"
snakeToCamel('') // ""
snakeToCamel('hello') // "Hello"
snakeToCamel('is_42_the_answer') // "is42TheAnswer
```

### Задачка про наследование

Реализовать функцию `extends`, которая будет наследовать один класс от другого.

```javascript
function extends(child, parent) {
  /* solution */
}

extends();
```

### Кастомный оператор new

На этом месте может быть задачка на создание полифилла для какого-либо метода (например, для `Object.create` или `bind`).

Задача: написать кастомный оператор `new`. Функция должна принимать функцию-конструктор и её аргументы, а возвращать инстанс класса.

```javascript
function newOperator(constr, args) {
  /* solution */
}
```

[Авторское решение](https://gist.github.com/batogov/74fbf8db6c98bd971526292ce8379610)

### Вывести все простые числа от 1 до N

Первая простенькая алгоритмическая задачка — нужно вывести все простые числа от 1 до N. На месте этой задачи может оказаться задача про числа Фибоначчи.

```javascript
function primesToN() {
  /* solution */
}

primesToN(0)
primesToN(1)
primesToN(10)
primesToN(100)
```

### Изоморфные строки

Ваша задача написать функцию, которая проверит, являются ли строки изоморфными.

Две строки называются изоморфными, когда в строке A можно заменить конкретный символ на любой другой для получения строки B. Порядок символов должен остаться неизменным. Каждый последовательный символ в строке A сравнивается с каждым последовательным символов в строке B.

В этом месте могут быть любые задачи со строками (например, анаграммы).

```javascript
function isIsomorphic(firstString, secondString) {
  /* solution */
}

isIsomorphic('foo', 'bar') // false
isIsomorphic('apple', 'orange'); // false
isIsomorphic('title', 'paper'); // true
isIsomorphic('', '') // true
```

### Сумма листьев бинарного дерева

Последняя алгоритмическая задачка будет самой сложной. С деревьями надо уметь работать. DOM-дерево — это тоже дерево.

### Удалить повторяющиеся элементы в массиве

Задачки с массивами. Тут же можно написать и про стек, про очередь и прочее. Может быть задачка про пересечение двух массивов.

Задача: удалите все одинаковые значения в массиве и верните массив, состоящий из уникальных элементов. Порядок элементов не важен.

```javascript
function uniqueArray(array) {
  /* solution */
}

uniqueArray([2, 1, 3, 5, 6, 1, 3]) // [2, 1, 3, 5, 6]
uniqueArray([1, 1, 1]) // [1]
uniqueArray([]) // []
uniqueArray([1, 2, 3]) // 1, 2, 3
```

### Каррирование

 [Каррирование](https://ru.wikipedia.org/wiki/%D0%9A%D0%B0%D1%80%D1%80%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5) или карринг (currying) в функциональном программировании — это преобразование функции с множеством аргументов в набор вложенных функций с одним аргументом. При вызове каррированной функции с передачей ей одного аргумента, она возвращает новую функцию, которая ожидает поступления следующего аргумента. Новые функции, ожидающие следующего аргумента, возвращаются при каждом вызове каррированной функции — до тех пор, пока функция не получит все необходимые ей аргументы.

```javascript
function curry(fn) {
  /* solution */
}

const add = function(a, b, c) {
  return a + b + c;
}

const curriedAdd = curry(add);

curriedAdd(1, 2, 3) // 6
curriedAdd(1)(2, 3) // 6
curriedAdd(1)(2)(3) // 6
curriedAdd(1) // λ
```

[Авторское решение](https://gist.github.com/batogov/c6ea322ca4dc77f029d057b30f07e3bb)
